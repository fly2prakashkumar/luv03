/**
 * Core Philosophy: This ruleset enforces a strict user-ownership model. All user-specific data,
 * including shopping carts, orders, and AI recommendations, is private and accessible only by the
 * authenticated owner. The product catalog is treated as public data, readable by anyone, but
 * write access is restricted to prevent unauthorized modifications.
 *
 * Data Structure: User data is organized hierarchically under the `/users/{userId}` path. This
 * path-based ownership simplifies authorization checks. A separate top-level collection, `/products`,
 * stores the public product catalog, segregating public and private data for security and performance.
 *
 * Key Security Decisions:
 * - User Isolation: Users can only read or write documents within their own data tree (e.g., `/users/THEIR_OWN_ID/...`).
 * - No User Listing: It is not possible for any client to list all documents in the `/users` collection.
 * - Public Catalog: The `/products` collection is publicly readable to allow anonymous browsing of the e-commerce store.
 * - Admin-Only Product Writes: Only an authenticated admin user (with a specific UID) can create, update, or delete products.
 *
 * Denormalization for Authorization: The rules rely on path-based ownership (`/users/{userId}`), which
 * is a highly performant authorization strategy that avoids costly `get()` calls. For documents
 * within a user's subcollection, we enforce that a `userAccountId` field is present on creation and
 * remains immutable, ensuring a permanent and verifiable link to the parent user.
 *
 * Structural Segregation: The separation of private data (`/users`) and public data (`/products`) into
 * distinct top-level collections is a deliberate design choice. This prevents accidental data exposure
 * and allows for highly efficient and secure list operations (queries) on the public product catalog.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions for reusable logic
    function isSignedIn() {
      return request.auth != null;
    }

    // Checks if the requesting user's UID matches the document's owner ID from the path.
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    // Verifies a document exists before an update or delete operation.
    function isExistingDocument() {
      return resource != null;
    }

    // Combines ownership and existence checks for state-changing operations.
    function isExistingOwner(userId) {
      return isOwner(userId) && isExistingDocument();
    }
    
    function isAdmin() {
      // Using UID for admin check is more secure than email.
      return isSignedIn() && request.auth.uid == 'K9wYgsFQBFYIZUZlmsLNAIIcYqF3';
    }

    /**
     * @description Rules for UserAccount documents, which store user profile and address information.
     * @path /users/{userId}
     * @allow (create) An authenticated user creating their own user account document. `request.auth.uid == userId`.
     * @deny (get) An authenticated user trying to read another user's account document.
     * @principle Restricts access to a user's own data tree and prevents user enumeration.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false; // Disallow listing all users for security and privacy.
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);

      /**
       * @description Rules for a user's ShoppingCart, containing product references.
       * @path /users/{userId}/shoppingCarts/{shoppingCartId}
       * @allow (get, list, create, update, delete) The owner of the user document accessing their own shopping cart.
       * @deny (get) A user trying to access another user's shopping cart.
       * @principle Enforces document ownership for all operations within a user's private subcollection.
       */
      match /shoppingCarts/{shoppingCartId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && request.resource.data.userAccountId == userId;
        allow update: if isExistingOwner(userId) && request.resource.data.userAccountId == resource.data.userAccountId;
        allow delete: if isExistingOwner(userId);
      }

      /**
       * @description Rules for a user's Orders, representing their purchase history.
       * @path /users/{userId}/orders/{orderId}
       * @allow (get, list, create, update, delete) The owner of the user document accessing their own orders.
       * @deny (update) A user trying to modify another user's order history.
       * @principle Enforces document ownership for all operations within a user's private subcollection.
       */
      match /orders/{orderId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && request.resource.data.userAccountId == userId;
        allow update: if isExistingOwner(userId) && request.resource.data.userAccountId == resource.data.userAccountId;
        allow delete: if isExistingOwner(userId);
      }

      /**
       * @description Rules for AI-generated product recommendations for a specific user.
       * @path /users/{userId}/aiRecommendations/{recommendationId}
       * @allow (get, list, create, update, delete) The owner of the user document accessing their own recommendations.
       * @deny (create) A user trying to create a recommendation for another user.
       * @principle Enforces document ownership for all operations within a user's private subcollection.
       */
      match /aiRecommendations/{recommendationId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && request.resource.data.userAccountId == userId;
        allow update: if isExistingOwner(userId) && request.resource.data.userAccountId == resource.data.userAccountId;
        allow delete: if isExistingOwner(userId);
      }
    }

    /**
     * @description Rules for Product documents, which are part of the public product catalog.
     * @path /products/{productId}
     * @allow (get, list) Any user, including unauthenticated users, can view products.
     * @deny (create, update, delete) Write operations are restricted to admin users to protect catalog integrity.
     * @principle Provides public read access while securing write operations.
     */
    match /products/{productId} {
      allow get: if true;
      allow list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }
  }
}
