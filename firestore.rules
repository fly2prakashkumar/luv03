/**
 * Core Philosophy: This ruleset enforces a strict user-ownership model. All user-specific data,
 * including shopping carts, orders, and AI recommendations, is private and accessible only by the
 * authenticated owner. The product catalog is treated as public data, readable by anyone, but
 * write access is restricted to prevent unauthorized modifications.
 *
 * Data Structure: User data is organized hierarchically under the `/users/{userId}` path. This
 * path-based ownership simplifies authorization checks. A separate top-level collection, `/products`,
 * stores the public product catalog, segregating public and private data for security and performance.
 *
 * Key Security Decisions:
 * - User Isolation: Users can only read or write documents within their own data tree (e.g., `/users/THEIR_OWN_ID/...`).
 * - No User Listing: It is not possible for any client to list all documents in the `/users` collection.
 * - Public Catalog: The `/products` collection is publicly readable to allow anonymous browsing of the e-commerce store.
 * - Admin-Only Product Writes: Only an authenticated admin user (with a specific UID) can create, update, or delete products.
 *
 * Denormalization for Authorization: The rules rely on path-based ownership (`/users/{userId}`), which
 * is a highly performant authorization strategy that avoids costly `get()` calls. For documents
 * within a user's subcollection, we enforce that a `userAccountId` field is present on creation and
 * remains immutable, ensuring a permanent and verifiable link to the parent user.
 *
 * Structural Segregation: The separation of private data (`/users`) and public data (`/products`) into
 * distinct top-level collections is a deliberate design choice. This prevents accidental data exposure
 * and allows for highly efficient and secure list operations (queries) on the public product catalog.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions for reusable logic
    function isSignedIn() {
      return request.auth != null;
    }

    // Checks if the requesting user's UID matches the document's owner ID from the path.
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    // Verifies a document exists before an update or delete operation.
    function isExistingDocument() {
      return resource != null;
    }

    // Combines ownership and existence checks for state-changing operations.
    function isExistingOwner(userId) {
      return isOwner(userId) && isExistingDocument();
    }
    
    function isAdmin() {
      // Using UID for admin check is more secure than email.
      return isSignedIn() && (request.auth.uid == 'K9wYgsFQBFYIZUZlmsLNAIIcYqF3' || request.auth.token.email == 'admin@gmail.com');
    }

    /**
     * @description Rules for UserAccount documents.
     * Admins need `get` access to user documents so that collection group queries can work.
     * A collection group query needs to check the parent document's existence.
     */
    match /users/{userId} {
      allow get: if isOwner(userId) || isAdmin();
      allow list: if isAdmin(); // Allow admins to list all users for dashboard.
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);

      /**
       * @description Rules for a user's saved addresses.
       */
      match /addresses/{addressId} {
        allow read, update, delete: if isOwner(userId);
        allow create: if isOwner(userId) && request.resource.data.userId == userId;
      }

      /**
       * @description Rules for a user's ShoppingCart.
       */
      match /shoppingCarts/{shoppingCartId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && request.resource.data.userAccountId == userId;
        allow update: if isExistingOwner(userId) && request.resource.data.userAccountId == resource.data.userAccountId;
        allow delete: if isExistingOwner(userId);
      }
      
      /**
       * @description Rules for AI-generated product recommendations for a specific user.
       */
      match /aiRecommendations/{recommendationId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && request.resource.data.userAccountId == userId;
        allow update: if isExistingOwner(userId) && request.resource.data.userAccountId == resource.data.userAccountId;
        allow delete: if isExistingOwner(userId);
      }
      
      /**
       * @description Rules for a user's orders. A user can read their own orders.
       */
      match /orders/{orderId} {
        allow list, get: if isOwner(userId);
        // Allow user to cancel their own order if it is still 'placed'
        allow update: if isOwner(userId) 
                      && resource.data.status == 'placed' 
                      && request.resource.data.status == 'cancelled'
                      && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status']);
      }
    }

    /**
     * @description Collection group rules for all `orders` collections.
     * This is required for the admin dashboard to query all orders across all users.
     */
    match /{path=**}/orders/{orderId} {
        // Admin can list all orders for the dashboard.
        allow list, update: if isAdmin();
        // An admin can get any order. A user can only get their own order.
        allow get: if isAdmin() || isOwner(resource.data.userAccountId);
        // A user can create an order for themselves.
        allow create: if isOwner(request.resource.data.userAccountId);
        // Nobody can delete orders from the client-side for data integrity.
        allow delete: if false;
    }

    /**
     * @description Rules for Product documents, which are part of the public product catalog.
     */
    match /products/{productId} {
      allow get: if true;
      allow list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin(); // Only admins should update products
      allow delete: if isAdmin();
    }
  }
}